<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>Scroll Rack | Design Pattern</title>
    
    <link href="../../style.css" rel="stylesheet">
</head>
<body>
    
    <toggle-menu>
        <svg xmlns="http://www.w3.org/2000/svg" version="1.1" x="0" y="0" viewBox="-58.5 250.5 118 500" enable-background="new -58.5 250.5 118 500" xml:space="preserve">
    <path d="M0.5 705.4L59.8 750.5V602.5v-92.6V250.5H-58.8v352h0.1L-58.8 750.5 0.5 705.4z"/>
</svg>

    </toggle-menu>
    
    <nav>
            <section-nav-title>typescript</section-nav-title>
            <ul>
                <li><a href="/typescript/1_why/">Why using Typescript</a></li>
                <li><a href="/typescript/2_definition_files/">Definition Files</a></li>
                <li><a href="/typescript/3_api_specification/">API Specification</a></li>
            </ul>
            <section-nav-title>angular</section-nav-title>
            <ul>
                <li><a href="/angular/1_introduction/">Introduction</a></li>
                <li><a href="/angular/2_design_pattern/">Design Pattern</a></li>
                <li><a href="/angular/3_handling_interaction/">Handling User Interactions</a></li>
                <li><a href="/angular/4_modules_di/">Modules &amp; Dependency Injection</a></li>
            </ul>
    </nav>
    <main>
    <article>
    	<h1>Design Pattern</h1>
    	<div><p>We want to keep our code modular and as reusable as possible. To achieve this we use the <em>container component</em> pattern, coined by <a href="https://facebook.github.io/react/">React</a>. The idea behind a container is can be summarized as:</p>
<blockquote>
<p>A container does data fetching and then renders its corresponding sub-component. Thatâ€™s it.</p>
</blockquote>
<p>What this basically means is that we separate our <strong>data-fetching</strong> and <strong>rendering</strong> concerns. This also benefits <strong>reusability</strong> of components. Because if we do not separate fetching data from rendering markup, we only could use the component under that exact circumstance (same API bindings and settings).</p>
<p>Instead the container component should pass data to its child components. Data should be passed via <strong>attribute bindings</strong> to the children and since these children should only be concerned with rendering, we&#39;ll call them <em>markup components</em>.</p>
<p>To summarize and clarify:</p>
<ul>
<li><strong>Container Components</strong> are only concerned with fetching data. They do not provide any visual user interface elements. Data is usually received by using one or more services.</li>
<li><strong>Markup Components</strong> are only concerned with rendering your interface. They know nothing about their surroundings. Instead all information they need is received via their attribute bindings.</li>
</ul>
<p>An example of this approach is shown below (ES6 only):</p>
<pre><code class="lang-typescript">angular.module(&#39;myModule&#39;, [])

    // Container Component
    .directive(&#39;userDataContainer&#39;, () =&gt; ({
        template: &#39;&lt;user-data user=&quot;vm.user&quot;&gt;&lt;/user-data&gt;&#39;,
        controller: class {
            constructor(userService) {
                this.userService = userService

                // User service to fetch data
                this.userService.get()
                    .then((user) =&gt; this.user = user)
            }
        },
        controller: &#39;vm&#39;,
        bindToController: true
    }))


    // Markup Component
    .directive(&#39;userData&#39;, () =&gt; ({
        template: `
            &lt;strong&gt;{{ user.name }}&lt;/strong&gt;
            &lt;div&gt;{{ user.email }}&lt;/div&gt;
        `,
        scope: {
            user: &#39;=&#39;
        }
    }))
</code></pre>
</div>
    </article>
    
        <footer-push></footer-push>
    </main>
    <footer>
        <time datetime="Thu Jul 09 2015 00:44:40 GMT+0200 (CEST)">Thu Jul 09 2015 00:44:40 GMT+0200 (CEST)</time>
    </footer>

</body>
</html>