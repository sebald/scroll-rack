<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>Scroll Rack  | Handling User Interactions</title>
</head>
<body>
    <header>
        <span>Path: angular/3_handling_interaction/index.html</span>
            <strong>typescript</strong><br>
            <ul>
                <li><a href="/typescript/1_why/">Why using Typescript</a></li>
                <li><a href="/typescript/2_definition_files/">Definition Files</a></li>
                <li><a href="/typescript/3_api_specification/">API Specification</a></li>
            </ul>
            <strong>angular</strong><br>
            <ul>
                <li><a href="/angular/1_introduction/">Introduction</a></li>
                <li><a href="/angular/2_design_pattern/">Design Pattern</a></li>
                <li><a href="/angular/3_handling_interaction/">Handling User Interactions</a></li>
                <li><a href="/angular/4_modules_di/">Modules &amp; Dependency Injection</a></li>
            </ul>
    </header>    <hr>
	<h1>Handling User Interactions</h1>
	<div><p>The above design pattern not only helps use to create reusable components. It also provides use with a clean way to let data flow through our application.</p>
<p>Some interactions with the UI affect model data. A common example is submitting a form or simply changing the value of an input field that updates another part of the UI. Since the only visible element to users (<em>markup components</em>) are not allowed to interact with data services, components can accept callbacks. The callbacks will be invoked when certain events occur.</p>
<p>In Angular, this can be done with the <code>&amp;</code> binding of an isolated scope. To enforce a unidirectional data flow all callbacks should be defined by a parent <em>container component</em> and have the form <code>handleAction</code>, where as action described the action to handle.</p>
<p>An component that lets users update their name and email could look like this:</p>
<pre><code class="lang-javascript">angular.module(&#39;myModule&#39;, [])

    .directive(&#39;editUser&#39;, () =&gt; ({
        template: `
            &lt;form name=&quot;EditUserForm&quot; ng-submit=&quot;vm.handleSubmit(vm.userData)&quot;&gt;
                &lt;input type=&quot;text&quot; ng-model=&quot;vm.userData.name&quot;&gt;
                &lt;input type&quot;email&quot; ng-model=&quot;vm.userData.email&quot;&gt;

                &lt;button type=&quot;submit&quot;&gt;Save&lt;/button&gt;
                &lt;button type=&quot;button&quot; ng-click=&quot;vm.reset()&quot;&gt;Cancel&lt;/button&gt;
            &lt;/form&gt;
        `,
        scope: {
            user: &#39;=&#39;,
            handleSubmit: &#39;&amp;&#39;
        },
        controller: class {
            constructor () {          
                this.userData = Object.assign({}, this.user)
            }

            reset () {
                this.userData = this.user
            }
        },
        controllerAs: &#39;vm&#39;,
        bindToController: true
    }))
</code></pre>
<p>Rather than directly expose the passed <code>user</code> variable, a local <code>userData</code> variable is created. When the user wants to save his changes the <code>handleSubmit()</code> is called, which defined via the attribute binding <code>&amp;</code>. To complete this small app, there has to be a a container that provides the <code>&lt;edit-user&gt;</code> component with the user data and a submit handler.</p>
<pre><code class="lang-javascript">angular.module(&#39;myModule&#39;, [])

    .directive(&#39;editUserContainer&#39;, () =&gt; ({
        template: `
            &lt;edit-user
                user=&quot;vm.user&quot;
                handle-submit=&quot;vm.updateUser(user)&quot;
            &gt;&lt;/edit-user&gt;
        `,
        scope: {},
        controller: class {
            constructor (userService) {
                this.userService = userService
                this.userService.get()
                    .then((user) =&gt; this.user = user)
            }

            updateUser ( user ) {
                this.userService.update(user)
                    .then((user) =&gt; this.user = user)
            }
        },
        controllerAs: &#39;vm&#39;,
        bindToController: true
    }))
</code></pre>
</div>
    <footer>
        <em>Tue Jul 07 2015 10:11:30 GMT+0200 (CEST)</em>
    </footer>

</body>
</html>